# java垃圾回收
Java的垃圾回收机制作为Java的一大特性，这个机制让java程序员们不那么关心内存管理，有效的防止内存泄漏的问题
- 什么是垃圾回收
  Java垃圾回收是通过一定的算法，找到jvm内存中没有被引用的对象，并将其回收释放其占用的内存空间
- 什么样的内存可以被回收
  说此知识点前先简单说一下Java的内存模型：
  
  ![内存模型](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/memery.png)

  - 程序计数器(Program Counter Register):是一块较小的内存空间，它的作用可以看做是当前线程所执行字节码的行号指示器。是线程私有，生命周期与线程相同。
  
  - Java虚拟机栈(ava Virtual Machine Stacks):也是线程私有的，它的生命周期与线程相同。 Java虚拟机栈描述的是Java方法（区别于native的本地方法）执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动作链接、方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
  
  - 本地方法栈(Native Method Stacks):与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机所使用到的Native方法服务。
  
  - Java 堆（Java Heap）:是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。
  
  - 方法区（MethodArea）:与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是Java 堆区分开来。
  
  其中，程序计数器、虚拟机栈和本地方法栈是线程私有的，这三个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，故这几个区域就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。
  
  对于java堆则是垃圾回收最关注的地方，因为堆中存放的实例变量，程序只有在运行时才会知道创建哪些对象，该部分的内存的分配和释放都是动态的。对于方法区(HotSpot中所谓的永久代)，垃圾回收主要关心废弃的常量和无用的类，废弃常量即是指系统中没有引用的常量。无用的类是指：
    - 类的所有实例都已被回收，即堆中已经没有该类的任何实例
    - 加载类的ClassLoader已经被回收
    - 该类的java.lang.Class对象没有任何地方引用，无法通过反射调用该类的方法。
    
  则满足条件的类称为无用类，可以进行回收。
  
- 垃圾回收算法：
  Java规范中没有明确使用哪种垃圾回收算法，任何一种垃圾回收算法都是发现无用的对象并进行回收。
  - 引用计数法：
    引用计数法是Java早期使用的垃圾回收算法。该方法是堆中的每个对象实例都有一个引用计数，每当有一个地方引用它的时候，它的计数器就加1，例如a=b，则b实例的引用计数加1，当引用失效时，引用计数减1，例如a=c，则b实例的引用计数减1。
    
    但引用计数法存在一个问题，就是无法检测出循环引用，例如
    
        objA.name = objB.name；  //objB的引用计数加1
        objB.age = objA.age;     //objA的引用计数加1
        
        objA = null;
        objB = null;
        
        此时两个对象即是都为null，却不能被回收，因为引用计数都还是1
        
  - 根搜索算法：
    根搜索是把程序中所有的引用关系看成一个图进行可达性分析，从任意一个GC Roots对象开始向下搜索，搜索过的路径称为引用链，当一个对象到任意一个GC Roots都没有引用链的时候表示GC Roots到该对象不可达，即该对象不可用。标记清除、标记整理和复制算法即使用根搜索算法。
    
    GC Roots的对象包括：
      
      - 所有Java线程活跃的栈帧指向堆中的对象的引用，即虚拟机栈（栈帧中的本地变量表）中引用的对象。
      - 方法区中静态static属性引用的对象
      - 方法区中常量final引用的对象
      - 本地方法栈中应用的对象（native 方法）
      - String常量池（StringTable）里的引用
      
    需要注意的是，即使在可达性分析（根搜索）算法中不可达的对象，也并非是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过（也就是说对象的finalize()方法只能被调用一次），虚拟机将这两种情况都视为“没有必要执行”。
    
    如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它（即去执行对象的finalize()方法，这里所谓的“执行”是值虚拟机会触发这个方法，但并不承若会等待它运行结束，主要是为了防止对象的finalize方法执行缓慢或发生死循环，导致其他对象不能被执行的，从而引起内存回收系统崩溃）。
    
    finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己――只需要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。

    因此对于不可达对象判定真正死亡的过程如下：
    - GC进行第一次标记并进行一次筛选（筛选那些覆盖了finalize方法并且finalize方法是第一次调用的对象）
    - 另一个低优先级的线程去调用那些被筛选出来的对象的finalize方法
    - GC进行第二次标记，如果在前一步中那些筛选出来的对象没有在finalize拯救自己，此时，那些未被筛选到的和这些这些筛选到的但是没有拯救自己的对象都将会回收。

  - 标记-清除法
  
    ![标记-清除](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/gcroots.jpg)
  
    标记清除法是一种早期的收集算法，采用二次标记清除的方法进行垃圾回收。但缺点明显：
      
    - 标记和清除效率都不高
    - 标记清除后产生大量的内存碎片，导致如果有大对象需要进行内存分配无法进行分配。
    
  - 复制算法
  
    ![复制算法](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/copy.jpg)
    
    为解决标记清除效率问题，产生复制算法，复制算法将内存分为大小相同两块，在任意时刻，对象内存分配只能在一个空间内进行，称为活动区，而另一个空间称为空闲区，则不进行内存分配。
    
    在需要垃圾清理时，JVM将暂停程序运行，开启复制算法。GC线程会将活动区存活的对象，全部赋值到空闲区，严格执行内存地址顺序依次排列，同时GC线程将更新存活对象的内存引用地址到新的地址。
    
    然后GC线程会清理掉之前活动区不可达的对象，此时空闲区与活动区交换。
    
    复制算法解决了标记清除中内存混乱的问题，但同时也有缺点：
    - 内存利用率低，直接浪费一半内存
    - 如果对象的存活率高的话，假如活动区的对象100%存活，那么复制时就要将所有的对象都复制一遍，并且要修改所有的引用地址，造成时间浪费。
    
    改进的复制算法，使用改进复制算法回收新生代。由于新生代一般存活周期比较短，所以不需要按照1：1进行空闲区与活动区的内存分配，转而使用一块大内存空间(Eden)和两块小内存空间(Survivor)。每次使用一块Eden和一块Survivor1，垃圾回收时，将Eden和Survivor1中的所有存活的对象都复制到Survivor2空间里，然后清空Eden和Survivor1，之后Eden和Survivor2变成活动区，Survivor1变成空闲区。此算法就是会存在Survivor2的内存不足以放下Eden和Survivor1中所有的存货对象，此时就会向老年代“借”内存，将剩余对象通过分配担保机制进入老年代。同样，在多次GC过程过后还仍然存活的对象，也会被推到老年代中，并跟随老年代使用的主要垃圾回收而清理和压缩空间。
      
    ![复制算法改进](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/copy-two.jpg)
    
  - 标记整理法
  
    ![标记整理](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/compacting.jpg)
    
    复制算法如果在对象存活率比较高的情况下就会不适用，效率降低。此时对于这些存活率高的对象应使用标记整理法。标记整理法与标记清除法的标记方式一样，只是标记之后不会立刻对对象进行回收，而是将存活的对象往同一端移动，然后清理掉端外的内存。
    
  - 分代收集法
    每一种垃圾收集算法都各有优劣，所以分代收集法就是根据不同特性的对象进行不同的算法进行收集，分代收集法也是当前商业虚拟机使用的垃圾收集算法。
    
    简单探讨一下不同对象的特性，根据对象的生命周期将对象分为以下三部分：
    - 新生代
      指生命周期短暂，创建后很快就会被回收掉的对象。例如：类局部变量、循环体内的临时变量等。
    - 老年代
      生命周期较长，几次GC都可能会存活下来的对象。例如：缓存、数据库连接对象、单例对象等
    - 永久代
      生命周期几乎与程序的生命周期相同，几乎在程序的运行过程不会进行回收。永久代包含有JVM描述应用程序使用的类和方法所需要的元数据。例如：String池中的对象，加载的类信息等。
      
    而新生代和老年代一般在Java堆中，而永久代则是在方法区中。对于java堆，jvm必须要对其进行GC。
    - Java堆新生代回收(minor garbage collection)：
      新生代存活率低，所以新生代最适合使用复制算法，而且一般使用的是前面提到的改进的复制算法
    - Java堆老年代的回收(major garbage collection)：
      由于老年代对象的存活率很高，而且有大多是新生代转换而来的，所以老年代更适合使用标记清除法或标记整理法。老年代的垃圾回收一般称为主要垃圾回收，通常该部分的垃圾回收要比新生代的垃圾回收慢，因为它涉及到所有的回收对象，因此对于响应式的应用程序尽量减少主要垃圾回收。
      
      通常，新生代变为老年代的情况有几种：
      
      - 新生代的年龄（熬过GC的次数）增大，则会变成老年代，这个年龄阈值一般是可以设置的
      - 新生代改进的复制算法中，存活的对象超过了Survivor2空闲区所能容纳的范围，则多余的新生代对象会进入到老年代。
       
    - 方法区的对象回收：
      以上两种情况已经解决了大多数的GC问题，方法区的对象回收一般也不算做是分代垃圾回收的范围。
      
      方法区中的对象一般被称作永久代，而永久代的垃圾回收与老年代类似，都是一般使用标记清除或标记整理法，只是回收时机不同。
    
    - Stop the world：所有的新生代和老年代的垃圾收集GC过程都是stop the world事件，即所有应用程序的线程都会停止，直到垃圾回收的操作完成。
- GC垃圾收集器
  - 常见的堆相关参数：
 
参数 | 描述
--------------- | -------------
-Xms			| 设置JVM启动时的初始堆大小
-Xmx			| 设置最大堆大小
-Xmn			| 设置年轻代的大小
-XX:PermSize	| 设置永久代的起始大小
-XX:MaxPermSize	| 设置永久代的最大大小
    
  - 串行GC (Serial)
    串行GC时java5和java6中的客户端默认GC。串行收集器对新生代和老年代的垃圾回收都是串行完成的，它是单线程的，在垃圾收集的过程中会进行Stop the world事件。
    
    - 用法案例：
      - 对于大多数没有短暂暂停时间要求的客户端应用程序，首选串行GC，它只使用单个虚拟处理器进行垃圾收集工作。
      - 另一个常用的地方是在一台机器上运行大量的jvm的环境中，在这种情况下当JVM进行垃圾收集时，最好只使用一个处理器来最小化最剩余JVM的干扰。 

  - 并行GC (Parallel GC)
    并行GC是使用多个线程来执行新生代的垃圾收集工作，在N个CPU的主机上，并行GC使用N个线程进行垃圾收集。在单个CPU的主机上，即使请求并行处理器，也会使用默认的垃圾收集器。
    
    - 用法案例：
      并行GC又称为吞吐量收集器，因为它可以使用多个CPU进行加速应用程序的吞吐量。当完成大量工作并可以接收暂停时，应用并行GC。
      例如：批处理、打印账单或执行大量数据库查询。
      
  - CMS收集器 (Concurrent Mark Sweep)
    CMS收集器是通过标记清除法实现的收集器，它尝试通过运行与应用程序同时执行的垃圾收集工作来最小化的解决由于垃圾收集导致的暂停，通常CMS使用的是标记清除法，不会复制和压缩对象，可能会产生内存碎片。
    
    - 用法案例：
      CMS收集器常用在响应请求的Web服务器或响应查询的数据库等。
      
  - G1垃圾收集器：
    G1是java7才发布的面向服务端的垃圾收集器。
    
    G1收集器的特点：
    - 并行与并发：G1充分利用多CPU来缩短垃圾收集的暂停时间
    - 分代收集：G1不需要其他收集器配合就能独自管理GC堆，对不同时期的对象采用不同的方式收集
    - 压缩空间：与CMS不同是的G1整体看起来是基于标记整理法的，所以不会产生内存碎片
    - 可预测停顿时间
    
- 相关书籍：深入理解Java虚拟机
- 参考：<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">Java垃圾收集基础知识</a>