# 计算机网络基础

## 概述
计算机网络的核心内容即是网络协议，网络协议就是计算机网络中进行数据交换建立的规则、标准或者说是约定。

## OSI七层模型
为了使不同的计算机厂家生产的计算机能够相互通信，国际标准组织（ISO）在1978年提出了“开放系统互联参考模型”，它将计算机体系结构的通讯协议分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。
除标准的OSI七层模型外，还有很多其他类型的层次划分，常见的有TCP/IP四层协议及TCP/IP五层协议。

![osi](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/osi.jpg)

#### 物理层
物理层处理的单位是比特，该层为上层数据链路层提供传输数据可靠的物理媒介，实现透明的比特流传输服务，确保原始的数据可以在各种物理设备上传输。物理层相关的重要设备有中继器和集线器

#### 数据链路层
数据链路层传输的PDU（协议数据单元）是帧，最基本的服务是将源自网络层来的数据可靠的传输到相邻节点的目标机网络层。
- 数据链路层主要作用
  - 物理地址寻址
  - 数据组合成帧
  - 流量控制
  - 数据检错
  - 重发
  
- 数据链路层主要内容
  - 数据链路层为网络层提供了可靠的数据传输
  - 基本传输单位为帧
  - 主要协议是以太网协议
  - 主要设备有：网桥和交换机
  
#### 网络层
网络层传输的的PDU（协议数据单元）是数据包，网络层实现的目的是两个端系统之间的数据的透明传输。具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。
- 网络层主要知识
  - 网络层负责对子网的数据包进行路由选择
  - 基本单位为IP数据报
  - 主要协议有：
    - IP协议：因特网互联协议
    - ICMP协议：因特网控制报文协议
    - ARP协议：地址解析协议
    - RARP协议：逆向地址解析协议
  - 主要设备有：路由器
  
#### 传输层
传输层传输的的PDU（协议数据单元）是数据段或报文，从端到端，即主机到主机，传输层负责将上层的数据分段并提供端到端的，可靠或不可靠的传输。同时也会处理端到端的差错控制和流量控制问题。
- 主要协议：TCP协议（传输控制协议）、UDP协议（用户数据报协议）

#### 会话层
会话层在传输层的基础上增加控制会话的机制，建立、组织和协调应用进程之间的交互过程，会话层提供的会话服务种类包括双工、半双工和单工方式。会话管理的另一种方式是令牌管理，只有令牌的持有者才能执行某种操作，会话层提供会话的同步控制，当出现故障的时候，会话活动在故障点之前的同步点进行重复，而不必从头开始

#### 表示层
表示层定义用户或应用程序之间交换数据的格式，提供数据表示之间的转换服务，保证传输的信息到达目的端后意义不变

#### 应用层
应用层直接面向用户，为用户提供各种网路资源的方便访问服务
- 包含的主要协议：
  - FTP文件传输协议
  - Telnet远程登陆协议
  - DNS域名解析协议
  - SMTP邮件传输协议
  - POP3邮局协议
  - HTTP协议
  
## IP地址详解
IP地址是在互联网中标记一台设备的一串数组组成的地址。每一个IP地址都是由网络号和主机号组成，通常使用32为二进制地址表示

主机地址全为0表示网段地址，主机地址全为1表示广播地址。

#### IP地址类别划分：

![IP](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/ip.png)

其中只有A、B、C有网络号和主机号之分，而D和E类地址没有划分网络号和主机号

A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255

B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255

C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255

D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）

E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用

## 子网掩码
子网掩码标志两个IP地址是否同属于一个子网，也是32位的二进制地址。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。

A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。

#### 判断两个地址是否属于同一个子网
将两个IP地址与子网掩码进行`与`运算，如果得到的结果相同，则说明属于同一个子网。

#### 子网掩码的表示方法：
- 使用与ip地址格式相同的点分十进制表示，如255.255.255.0
- 在IP地址后加上“/”符号以及1-32的数字，数字表示子网掩码中网络标识符的长度

      如:192.168.1.1/24 中的24表示子网掩码的网络标识符为24位，即：
      
      11111111 11111111 11111111 00000000
      
      255.255.255.0
      

#### 子网掩码是如何划分子网的

例如子网掩码255.255.255.252是如何划分子网的。

转化为二进制为：

    11111111 11111111 11111111 11111100
    
其中主机位中0的个数有两个，子网掩码主机位中的0不会影响主机ip与子网掩码进行`与运算`的结果，所以0的个数就决定了一个子网中主机IP的个数 ，则每个子网中包含的ip地址为：2^2 = 4 个

那么网段是192.168.1.0的地址最多可以划分为 256 / 4 = 64 个子网，即:

    192.168.1.0 ~ 192.168.1.3
    192.168.1.4 ~ 192.168.1.7
    192.168.1.8 ~ 192.168.1.11
    ...
    192.168.1.252 ~ 192.168.1.255
    
而每个子网中，第一个IP用于代表网段地址，最后一个IP代表广播地址，所以每个子网只能容纳两台主机
    
#### 反过来根据子网划分算子网掩码

假设将C类网段192.168.1.0划分为4个子网，子网掩码应该是什么样的，各网段都是什么。

C类地址192.168.1.0 共有256个IP地址，划分为4个子网，即每个子网有64个IP地址

而 2^6 = 64 ，所以C类IP的默认子网掩码255.255.255.0的最后一个字节应该有6个0即

    11111111 11111111 11111111 11000000
    
所以该网段子网掩码应该为255.255.255.192 ，各子网为：

    192.168.1.0 ~ 192.168.1.63
    192.168.1.64 ~ 192.168.1.127
    192.168.1.128 ~ 192.168.1.191
    192.168.1.192 ~ 192.168.1.255
    
其中，每个子网中有64各IP，第一个为网段IP，最后一个为广播IP，可用IP为62个，即每个子网可以有62台主机
    
#### 注意

子网掩码中并没有规定一串1必须是连续的，但是不建议不连续。

## 子网掩码计算方法：
计算子网掩码位数对应每个子网主机的数目。定义子网掩码之前需要清楚本来使用的子网数目和主机数目

#### 根据子网数进行计算
在求子网掩码之前需要知道需要划分的子网数目和每个子网内的所需要的主机的数目
- 将子网数目转化为二进制
- 取得二进制的位数为N
- 根据IP当前的类别（A类B类C类）取对应的默认子网掩码，将其主机地址的前N位置为1，即为子网划分的子网掩码。

    例：将IP地址168.195.0.0划分为27个子网
    
    27转换为二进制为：11011
    
    二进制的位数 N = 5
    
    该IP为B类，所以对应的子网掩码为：255.255.0.0，即：
        
              网络号     |     主机位
        11111111 11111111 00000000 00000000
    
    将主机位前5位置1，即：
    
        11111111 11111111 11111000 00000000
        
    得到 255.255.248.0
    
    即为划分成27个子网的B类IP地址 168.195.0.0的子网掩码为255.255.248.0 （实际是划分成32个子网）

- NOTE：子网掩码的主机位中的1表示子网号，0表示主机号，所以：
  - 子网号的位数为m，则2^m表示该子网掩码划分子网的数目
  - 主机号的位数为n，则2^n表示该子网掩码每个子网主机的数目

![zwym](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/zwym.png)
   
      
#### 根据主机数
- 将主机数转化为二进制
- 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为 N，这里肯定N<8。如果大于254，则 N>8，这就是说主机地址将占据不止8位。
- 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值

      例：将IP地址168.195.0.0划分为若干个子网，每个子网有700台主机
      
      将700转换为二进制为 1010111100，即N = 10
      
      将该类地址为B类IP，所以子网掩码为255.255.0.0 ，将主机地址全部置1为：255.255.255.255
      
      然后从后往前N=10位置为0，即：
      
          11111111 11111111 11111100 00000000
          
      即子网掩码为 255.255.252.0
      
#### 子网掩码常用计算
- 根据子网掩码和IP求该IP网段被分为多少子网和范围
  - A类IP默认子网掩码为255.0.0.0 ，其中主机位为24位，默认的子网掩码中每个子网中的IP数为2^24=16777216个主机，而A类IP共有 2^24=16777216个ip，所以子网数为1个，范围为 ***.0.0.0 ~ ***.255.255.255
  - B类IP默认子网掩码为255.255.0.0，其中主机位为16位，默认的子网掩码中每个子网的IP数为2^16=65536个，而B类IP共有2^16=65536个ip，所以子网数为1，范围为***.***.0.0 ~ ***.***.255.255
  - C类IP默认子网掩码为255.255.255.0，其中主机位为8位，默认的子网掩码中每个子网的IP数为2^8=256个，而C类IP共有2^8=256个ip，所以子网数为1,范围为***.***.***.0 ~ ***.***.***.255
  - 实例：C类地址网段192.168.1.0，子网掩码为255.255.255.216
    	
    	IP网段为192.168.1.0，子网掩码为255.255.255.216
  
        将子网掩码转换为二进制  11111111 11111111 11111111 11011000 
        子网掩码中主机位0的个数为4，2^4 = 16 每个子网16个ip
        该ip网段共256个ip
        子网数为256 / 16 = 16个子网
        但由于子网掩码中1是不连续的，所以每一个子网的地址都不一定都是连续的，所以该子网掩码虽然是有效的，但不是推荐的：
            
        其中，主机位后8位中，第1、2、4、5位相同的IP地址为同一子网，第3、6、7、8确定每个子网中的具体主机IP地址
            
        第一个子网为：
        11000000 10101000 00000001 00000000   192.168.1.0
        11000000 10101000 00000001 00000001   192.168.1.1
        11000000 10101000 00000001 00000010   192.168.1.2
        11000000 10101000 00000001 00000011   192.168.1.3
        11000000 10101000 00000001 00000100   192.168.1.4
        11000000 10101000 00000001 00000101   192.168.1.5
        11000000 10101000 00000001 00000110   192.168.1.6
        11000000 10101000 00000001 00000111   192.168.1.7
        11000000 10101000 00000001 00100000   192.168.1.32
        11000000 10101000 00000001 00100001   192.168.1.33
        ... 省略5个                           ...
        11000000 10101000 00000001 00100111   192.168.1.39
        
        并且该子网中的网段地址为192.168.1.0，广播地址为192.168.1.39，可用的主机地址为14个

- 给出IP地址和子网掩码求网络地址等
  
  特定的IP地址与其子网掩码进行`与运算`即为网络地址，也可以根据推算得出
  
      例：某IP地址为192.168.100.200，子网掩码为255.255.255.192，求网络地址，主机IP地址，广播地址
      
      两种方法：
      
      方法1.相与运算得到网络地址，根据主机数算出子网范围
      
          11000000 10101000 01100100 11001000  192.168.100.200
          11111111 11111111 11111111 11000000  255.255.255.192
          相与运算得到：
          11000000 10101000 01100100 11000000  192.168.100.192
          
          即网络地址为192.168.100.192
          
          返回看子网掩码，主机位0的个数为6个，即2^6=64 ，每个子网中有64个主机ip地址
          
          所以该网络地址的范围为192.168.100.192 ~ 192.168.100.255
          
          即网络地址为192.168.100.192，广播地址为192.168.100.255，主机IP地址范围为192.168.100.193 ~ 192.168.100.254
      
      方法2.根据子网掩码和ip进行推算
      
          子网掩码255.255.255.192将IP网段192.168.100.*划分成了256/64=4个子网，每个子网有64个ip地址
          
          所以所有子网如下：
          192.168.100.0 ~ 192.168.100.63
          192.168.100.64 ~ 192.168.100.127
          192.168.100.128 ~ 192.168.100.191
          192.168.100.192 ~ 192.168.100.255
          
          通过对比很容易得出192.168.100.200的子网信息。
      
- 给出IP地址和子网数，求子网掩码
  
  将C类IP网段192.168.1.0划分为5个子网，子网掩码可以怎么设置。
  
  	  方法1：根据常规方法推算默认子网掩码主机位1的个数
    
      5转换为二进制为：101
      
      二进制的位数 N = 3
      
      该IP为C类，所以对应的子网掩码为：255.255.255.0，即：
          
          11111111 11111111 11111111 00000000
          前三个字节位网络号，最后一个字节位主机位
      
      将主机位前3位置1，即：
      
          11111111 11111111 11111111 11100000
          
      得到 255.255.255.224
      
      即为划分成5个子网的C类IP地址 192.168.1.0的子网掩码为255.255.255.224 （实际是划分成8个子网）
      
  方法2：
  
      子网掩码的划分实际只能刚好划分到2的指数倍的数目，如果划分的数字不是2的指数倍，则取子网数为大于要求划分的子网数最近的2的指数倍数字
      
      例如5不是2的指数倍，则取大于5且最接近5的2的指数倍数字8作为划分的子网数
  
      C类地址包含的主机IP数为2^8=256个，如果分成8个子网则每个子网有256/8=32个IP地址
      
      2^5=32，则子网掩码中主机位中的0的个数为5个，所以子网掩码为：
      
          11111111 11111111 11111111 11100000
          
      得到255.255.255.224
      
#### 网关 
      
网关（Gateway）又称作网间连接器、协议转换器，网关实现在网络层以上实现的网络互联
  
如果两个子网或两个网络之间要进行通信，则每个网络中还需要一个网关地址，即每个网络的构成为一个网段地址、一个广播地址、一个网关地址和多个主机地址构成

网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为`192.168.1.1~192. 168.1.254`，子网掩码为255.255.255.0；网络B的IP地址范围为`192.168.2.1~192.168.2.254`，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机

网关的ip地址是具有路由功能的设备的IP地址，如：路由器、启用了路由协议的服务器、代理服务器，实际都相当于路由器。

## ARP/RARP协议

#### ARP地址解析协议
地址解析协议，是根据IP地址获取物理地址的一个TCP/IP的协议。

ARP的工作流程示例：
主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；
主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；
当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：
- 根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。
- 如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。
- 主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。
- 主机B将包含其MAC地址的ARP回复消息直接发送回主机A。
- 当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。

#### RARP逆向地址解析协议
逆向地址解析协议与地址解析协议类似，该协议是将局域网中某个物理地址转换成IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。

RARP工作流程
- 给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；
- 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；
- 如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；
- 如果不存在，RARP服务器对此不做任何的响应；

## TCP/IP协议
TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。


IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。

TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用"带重传的肯定确认"技术来实现传输的可靠性。TCP还采用一种称为"滑动窗口"的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。

TCP的三次握手与四次挥手：

![tcp](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/tcpconnect.png)

seq:"sequance"序列号；ack:"acknowledge"确认号；SYN:"synchronize"请求同步标志；；ACK:"acknowledge"确认标志"；FIN："Finally"结束标志。

- TCP连接建立过程

  首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。
  
- TCP连接断开过程

  假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。"，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

- 为什么要三次握手

  在只有两次"握手"的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据...问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，"三次握手"很有必要！
  
- 为什么要四次挥手

  试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。

## UDP协议

UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。

UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。

UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。

每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：

- 源端口号
- 目标端口号
- 数据报长度
- 校验值

使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。

## DNS协议

DNS为域名解析协议，可以将域名解析成IP地址

## NAT协议

NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。

## DHCP协议

DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

## HTTP协议

超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。

#### http请求报文内容

![http](https://github.com/Xchunguang/java-review-docs/blob/master/docs/img/http.png)

http请求报文由请求行、请求头、空行和请求数据4个部分组成

- 请求行

  请求行由请求方法字段、url字段和http协议版本三个字段组成，他们用空格分开，例如GET /index.html HTTP/1.1    。HTTP协议请求方法有POST、GET、PUT、DELETE、OPTIONS、TRACE、CONNECT
- GET
  
  最常见的一种请求方式，当客户端从服务器中读取文档的时候，当点击网页上的连接或者通过在浏览器的地址栏输入网址来浏览网页，使用的都是ＧＥＴ方法。ＧＥＴ方法要求服务器URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对象的值在URL后，传递参数的长度受限制。GET方式的请求一般不包括请求内容部分，请求数据以地址形式出现在请求行。显然，这种方式不适合传送私密数据，一般最多只能识别1024个字符，所以需要传动大量数据的时候，也不适合GET方式。
- POST

  使用POST方法可以允许客户端给服务器提供信息较多，POST方法将请求参数封装到HTTP请求数据中，以名称/值的形式出现，可以传输大量的数据，这样POST方式对传输的数据大小没有限制，而且也不会显示在URL 中
- HEAD

  HEAD类似于GET只不过服务器端接受到HEAD请求后只返回相应头，而不会发送相应内容，当我们需要只查看某个页面的状态的时候，使用HEAD是非常高校的，因为在还窜书的过程中省去了页面内容。
- 请求头部

  请求头部有关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户都啊请求的信息，典型的请求头有：
    User-Agent：产生请求的浏览器类型
    Accept：客户端可识别的内容类型列表
    Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
- 空行
 
  最后一个请求有的之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。
- 请求数据

  请求数据不在GET方法中使用，而是在POST方法中使用，POST方法使用与需要客户填写表单的场合，与请求数据相关的最常使用的请求头饰Content-Type和Content-Length

#### http响应报文内容

HTTP响应也分为三个组成部分：状态行、消息报文、响应正文。在响应中唯一正真的区别就是在于第一行中用状态信息代替了请求信息，状态行通过提供一个状态码来说明所请求的资源情况

- 状态行如下

  HTTP：Version Status-Code Reason-Phrases CRLF

  其中，HTTP-Version表示服务器HTTP协议的版本，Status-Code表示服务器发回的响应状态码，Reason-Phrase表示状态代码的文本描述，状态代码由三位数字组成，第一个数字定义了响应类别，并且有五种可能：

  - 1xx:指示信息，表示请求已接受，继续处理
	- 2xx：成功，表示请求已经被成功接收，理解和接受
	- 3xx：重定向，要完成请求必须进行更进一步的操作
	- 4xx：客户端错误，请求有语法错误或者请求无法完成
	- 5xx：服务器错误，服务器未能完成合法的请求

- 常见的状态码
      
      200：ok，客户端请求成功
      400：Bad Request，客户端请求有语法错误，不能被服务器所理解
      401：Unauthorized，请求未授权，这个状态码必须和www-Authenticate报文域一起使用
      403：Forbidden，服务器收到请求，但是拒绝提供服务
      404：Not Found，请求的资源不存在，URL可能出现错误
      500：Internal Server Error，服务器端发生了不可预知的错误
      503：Server Unavailable，服务器当前不能处理客户端的请求，一段时间后可能会恢复正常，例如HTTP/1.1 200OK(CRLF)

#### GET/POST区别 

- GET提交，请求的数据会附在URL 之后，就是把数据放置在HTTP协议头，以？分隔URL和传输数据，多个参数用&连接。POST提交，就是把提交的数据放置在HTTP包中的包体<request-body>中，GET提交的数据会在URL中显示出来，POST提交的数据不会显示。
- 传输的数据的大小，首先声明，HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制，而在实际的开发中存在的限制主要有：GET特定的服务器和浏览器对URL的长度会有限制、POST由于不是URL传值，理论上不受大小的限制，但实际上各个WEB服务器会规定对POST提交的数据大小进行限制，如Apache、IIS6
- 安全性：POST的安全性要比GET的安全性高，通过GET提交数据，用户名和密码就会在URL上显示，因为页面登录可能会被浏览器缓存，其他人可能查看浏览器的历史记录。

## 浏览器输入网址到打开页面的整个过程

现在假设如果我们在客户端（客户端）浏览器中输入 `http://www.baidu.com`， 而 baidu.com 为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：

- 客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。
- 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
- 客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
- 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。
